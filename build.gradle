buildscript {
    dependencies {
        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4"
    }
    repositories {
        jcenter()
        mavenCentral()
    }
}

plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '1.4.0'
    id 'org.ajoberstar.grgit' version '4.0.2'
    id 'maven-publish'
}

repositories {
    jcenter()
    mavenCentral()
}

def localProperties = new Properties()
def propertiesFile = rootProject.file('local.properties')
if (propertiesFile.exists()) {
    localProperties.load(propertiesFile.newDataInputStream())
}
group = 'nl.blackstardlb'
version = '0.0.10'

def getVcpkgInstallDir(vcpkgDir) {
    def dirName;
    if (isLinux) {
        dirName = "x64-linux"
    } else if (isMacos) {
        dirName = "x64-osx"
    } else if (isWindows) {
        dirName = vcpkg_triplets["windows"]
    } else throw new GradleException("Host OS is not supported in Kotlin/Native.")
    return file("$vcpkgDir/installed/$dirName")
}

def vcpkgExecutable() {
    if (isWindows) {
        return "vcpkg.exe"
    }
    return "vcpkg"
}

ext {
    hostOs = System.getProperty("os.name")
    isLinux = hostOs == "Linux"
    isMacos = hostOs == "Mac OS X"
    isWindows = hostOs.startsWith("Windows")
    gumbo_def_file = new File(projectDir, "src/nativeInterop/cinterop/gumbo.def")
    gumbo_ios_arm_def_file = new File(projectDir, "src/nativeInterop/cinterop/gumboIosArm.def")
    gumbo_ios_x64_def_file = new File(projectDir, "src/nativeInterop/cinterop/gumboIosX64.def")
    gumbo_lib_short_name = "sigil-gumbo"
    gumbo_lib = "libsigil-gumbo.a"
    test_resources_folder = new File(projectDir, "src/commonTest/resources")
    bintrayUser = localProperties.get("bintrayUser")
    bintrayApiKey = localProperties.get("bintrayApiKey")

    vcpkg_dir = new File(buildDir, "vcpkg")
    vcpkg_script = new File(vcpkg_dir, vcpkgExecutable())
    vcpkg_repo = "https://github.com/microsoft/vcpkg.git"
    vcpkg_branch = "origin/master"
    vcpkg_triplets = [windows: "x64-mingw-static", iosarm: "arm64-ios", iosx64: "x64-ios"]
    vcpkg_install_dir = getVcpkgInstallDir(vcpkg_dir)
    vcpkg_install_ios_arm_dir = file("$vcpkg_dir/installed/${vcpkg_triplets["iosarm"]}")
    vcpkg_install_ios_x64_dir = file("$vcpkg_dir/installed/${vcpkg_triplets["iosx64"]}")
}

def createDefFile(defFile, libDir) {
    if (!defFile.exists()) {
        defFile.createNewFile()
        defFile.text = """headers = include/gumbo.h
compilerOpts = -I${libDir.toString().replaceAll("\\\\", "/")}
staticLibraries = $gumbo_lib
libraryPaths = ${libDir.toString().replaceAll("\\\\", "/")}/lib 
"""
    }
}

task generateDefFiles() {
    dependsOn "cleanDefFiles"
    createDefFile(gumbo_def_file, vcpkg_install_dir)
    createDefFile(gumbo_ios_arm_def_file, vcpkg_install_ios_arm_dir)
    createDefFile(gumbo_ios_x64_def_file, vcpkg_install_ios_x64_dir)
}

println konanHome

gradle.taskGraph.whenReady { taskGraph ->
    def test = taskGraph.getAllTasks().find { it.name == "generateMetadataFileForKotlinMultiplatformPublication" }
    if (test != null) {
        def nTarget = kotlin.targets.find { it.name == "native" }
        kotlin.targets.remove(nTarget)
    }
    taskGraph.getAllTasks().each {
        if ((it.name.contains("Native") || it.name.contains("native")) && it.name != "cinteropGumboNative") {
            it.onlyIf { false }
        }
        if (!isLinux) {
            if (it.name.contains("Linux") || it.name.contains("linux")) {
                it.onlyIf { false }
            }
        }
    }
}

kotlin {
    jvm {
        compilations.all {
            kotlinOptions.jvmTarget = '1.8'
        }
    }

    iosX64() {
        compilations.main.cinterops {
            gumbo {
                defFile gumbo_ios_x64_def_file
                packageName "gumbo"
            }
        }
    }

    iosArm64() {
        compilations.main.cinterops {
            gumbo {
                defFile gumbo_ios_arm_def_file
                packageName "gumbo"
            }
        }
    }

    macosX64('macos') {
        compilations.main.cinterops {
            gumbo
        }
    }

    linuxX64("linux") {
        compilations.main.cinterops {
            gumbo
        }
    }

    mingwX64("windows") {
        compilations.main.cinterops {
            gumbo
        }
    }

    org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetWithTests nativeTarget
    if (isMacos) nativeTarget = macosX64('native')
    else if (isLinux) nativeTarget = linuxX64("native")
    else if (isWindows) nativeTarget = mingwX64("native")
    else throw new GradleException("Host OS is not supported in Kotlin/Native.")

    nativeTarget.compilations.main.cinterops {
        gumbo
    }

    configure([targets["metadata"], jvm()]) {
        mavenPublication { targetPublication ->
            tasks.withType(AbstractPublishToMaven)
                    .matching { it.publication == targetPublication }
                    .all { onlyIf { isLinux } }
        }
    }
    sourceSets {
        commonMain {

        }
        commonTest {
            dependencies {
                implementation kotlin('test-common')
                implementation kotlin('test-annotations-common')
            }
        }

        nativeMain {
            dependsOn(commonMain)
        }

        nativeTest {
            dependsOn(commonTest)
        }

        linuxMain.kotlin.srcDirs = [file("src/nativeMain")]
        linuxTest.kotlin.srcDirs = [file("src/nativeTest")]
        windowsMain.kotlin.srcDirs = [file("src/nativeMain")]
        windowsTest.kotlin.srcDirs = [file("src/nativeTest")]
        macosMain.kotlin.srcDirs = [file("src/nativeMain")]
        macosTest.kotlin.srcDirs = [file("src/nativeTest")]
        iosX64Main.kotlin.srcDirs = [file("src/nativeMain")]
        iosX64Test.kotlin.srcDirs = [file("src/nativeTest")]
        iosArm64Main.kotlin.srcDirs = [file("src/nativeMain")]
        iosArm64Test.kotlin.srcDirs = [file("src/nativeTest")]

        jvmMain {
            dependencies {
                implementation 'org.jsoup:jsoup:1.13.1'
            }
        }
        jvmTest {
            dependencies {
                implementation kotlin('test-junit')
            }
        }
    }
}

task cleanGumboDef(type: Delete) {
    delete(gumbo_def_file)
}

task cleanGumboIosArmDef(type: Delete) {
    delete(gumbo_ios_arm_def_file)
}

task cleanGumboIosX64Def(type: Delete) {
    delete(gumbo_ios_x64_def_file)
}

task cleanDefFiles(type: Delete) {
    dependsOn "cleanGumboDef"
    dependsOn "cleanGumboIosArmDef"
    dependsOn "cleanGumboIosX64Def"
    tasks.clean.dependsOn(cleanDefFiles)
}

def getBintrayUserProperty() {
    return bintrayUser != null ? bintrayUser : System.getenv('BINTRAY_USER')
}

def getBintrayApiKeyProperty() {
    return bintrayApiKey != null ? bintrayApiKey : System.getenv('BINTRAY_API_KEY')
}

task cleanVcpkg(type: Delete) {
    delete(vcpkg_dir)
    tasks.clean.dependsOn(cleanVcpkg)
}

task cloneVcpkg() {
    doLast {
        def gr = org.ajoberstar.grgit.Grgit.clone(dir: "$vcpkg_dir", uri: "$vcpkg_repo")
        gr.checkout(branch: "$vcpkg_branch")
    }
    onlyIf { !vcpkg_dir.exists() }
}

task bootstrapVcpkg(type: Exec, dependsOn: "cloneVcpkg") {
    def command = "$vcpkg_dir/bootstrap-vcpkg.sh"
    if (isWindows) {
        command = "$vcpkg_dir/bootstrap-vcpkg.bat"
    }
    workingDir vcpkg_dir
    commandLine command
    onlyIf { !file("$vcpkg_script").exists() }
    finalizedBy "addBitCodeFlag"
}

task addBitCodeFlag() {
    onlyIf { bootstrapVcpkg.didWork }
    doLast {
        file("$vcpkg_dir/triplets/community/arm64-ios.cmake").append("set(VCPKG_C_FLAGS \"-fembed-bitcode\")\n" +
                "set(VCPKG_CXX_FLAGS \"-fembed-bitcode\")")
        file("$vcpkg_dir/triplets/community/x64-ios.cmake").append("set(VCPKG_C_FLAGS \"-fembed-bitcode\")\n" +
                "set(VCPKG_CXX_FLAGS \"-fembed-bitcode\")")
    }
}

task makeGumbo(type: Exec) {
    if (isWindows) {
        commandLine "$vcpkg_script", "install", "$gumbo_lib_short_name", "--triplet", "${vcpkg_triplets["windows"]}", "--overlay-ports", "${projectDir}/ports"
    } else {
        commandLine "$vcpkg_script", "install", "$gumbo_lib_short_name", "--overlay-ports", "${projectDir}/ports"
    }
    dependsOn "bootstrapVcpkg"
    workingDir vcpkg_dir

    onlyIf { !file("$vcpkg_install_dir/lib/$gumbo_lib").exists() }
    finalizedBy { "makeIosArmGumbo" }
    finalizedBy { "makeIosX64Gumbo" }
}

task makeIosArmGumbo(type: Exec) {
    dependsOn "bootstrapVcpkg"
    workingDir vcpkg_dir
    commandLine "$vcpkg_script", "install", "--triplet", "arm64-ios", "$gumbo_lib_short_name", "--overlay-ports", "${projectDir}/ports"
    onlyIf { isMacos && !file("$vcpkg_install_ios_arm_dir/lib/$gumbo_lib").exists() }
}

task makeIosX64Gumbo(type: Exec) {
    dependsOn "bootstrapVcpkg"
    workingDir vcpkg_dir
    commandLine "$vcpkg_script", "install", "--triplet", "x64-ios", "$gumbo_lib_short_name", "--overlay-ports", "${projectDir}/ports"
    onlyIf { isMacos && !file("$vcpkg_install_ios_x64_dir/lib/$gumbo_lib").exists() }
}


tasks.each {
    if (it.name.startsWith("cinteropGumbo")) {
        it.dependsOn("makeGumbo")
    }
}

publishing {
    repositories {
        maven {
            name = "Bintray"
            url = uri("https://api.bintray.com/maven/blackstardlb/GumboSoup/gumbo-soup/;publish=1;override=1")
            credentials {
                username = getBintrayUserProperty()
                password = getBintrayApiKeyProperty()
            }
        }
    }
}

tasks.each {
    if (it.class.name == "org.jetbrains.kotlin.gradle.targets.native.tasks.KotlinNativeHostTest_Decorated") {
        it.doFirst {
            environment 'RESOURCES_FOLDER', "$test_resources_folder/"
        }
    }
    if (it.class.name == "org.jetbrains.kotlin.gradle.targets.native.tasks.KotlinNativeSimulatorTest_Decorated") {
        it.doFirst {
            environment 'SIMCTL_CHILD_RESOURCES_FOLDER', "$test_resources_folder/"
        }
    }
}
